<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MentionMarkets - Trump Transcript Analytics</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', sans-serif;
            background: #1a2332;
            color: #e5e7eb;
            font-size: 14px;
        }

        .container {
            max-width: 100%;
            padding: 20px;
        }

        /* SEARCH SECTION */
        .search-section {
            background: #2d3748;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 20px;
        }

        .search-title {
            font-size: 24px;
            font-weight: 600;
            margin-bottom: 15px;
            color: #3b82f6;
        }

        .search-input {
            width: 100%;
            padding: 12px 15px;
            background: #1a2332;
            border: 1px solid #374151;
            border-radius: 6px;
            color: #e5e7eb;
            font-size: 15px;
            margin-bottom: 15px;
        }

        .search-input:focus {
            outline: none;
            border-color: #3b82f6;
        }

        .search-options {
            display: flex;
            gap: 20px;
            flex-wrap: wrap;
            margin-bottom: 12px;
        }

        .search-option {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 13px;
        }

        .search-option input[type="checkbox"] {
            cursor: pointer;
        }

        .options-row {
            display: flex;
            gap: 15px;
            align-items: center;
            flex-wrap: wrap;
        }

        .option-label {
            font-size: 13px;
            color: #d1d5db;
        }

        .context-size-input {
            width: 80px;
            padding: 6px;
            background: #1a2332;
            border: 1px solid #374151;
            border-radius: 4px;
            color: #e5e7eb;
            font-size: 13px;
        }

        .sort-select {
            padding: 6px 10px;
            background: #1a2332;
            border: 1px solid #374151;
            border-radius: 4px;
            color: #e5e7eb;
            font-size: 13px;
            cursor: pointer;
        }

        .checkbox-group {
            display: flex;
            gap: 6px;
            align-items: center;
        }

        /* CHARTS SECTION */
        .charts-container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 20px;
        }

        .chart-wrapper {
            background: #2d3748;
            border-radius: 8px;
            padding: 20px;
            height: 400px;
        }

        .chart-title {
            font-size: 14px;
            font-weight: 600;
            margin-bottom: 15px;
            color: #f3f4f6;
        }

        .chart-canvas {
            height: calc(100% - 30px);
        }

        /* FILTERS SECTION - HORIZONTAL */
        .filters-section {
            background: #2d3748;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 20px;
        }

        .filters-title {
            font-size: 16px;
            font-weight: 600;
            margin-bottom: 15px;
            color: #f3f4f6;
        }

        .filters-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
        }

        .filter-group {
            display: flex;
            flex-direction: column;
        }

        .filter-group-title {
            font-size: 14px;
            font-weight: 600;
            margin-bottom: 10px;
            color: #d1d5db;
        }

        .filter-items {
            display: flex;
            flex-direction: column;
            gap: 8px;
            max-height: 200px;
            overflow-y: auto;
            background: #1a2332;
            padding: 10px;
            border-radius: 4px;
            border: 1px solid #374151;
        }

        .filter-item {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 13px;
        }

        .filter-item input[type="checkbox"] {
            cursor: pointer;
        }

        .filter-item label {
            cursor: pointer;
        }

        .filter-buttons {
            display: flex;
            gap: 10px;
            margin-top: 10px;
        }

        .filter-btn {
            padding: 6px 12px;
            background: #3b82f6;
            color: white;
            border: none;
            border-radius: 4px;
            font-size: 12px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .filter-btn:hover {
            background: #2563eb;
        }

        .filter-btn.secondary {
            background: #4b5563;
        }

        .filter-btn.secondary:hover {
            background: #6b7280;
        }

        .date-input {
            padding: 8px;
            background: #1a2332;
            border: 1px solid #374151;
            border-radius: 4px;
            color: #e5e7eb;
            font-size: 13px;
            width: 100%;
        }

        /* STATISTICS SECTION */
        .stats-section {
            background: #2d3748;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 20px;
        }

        .stats-title {
            font-size: 14px;
            margin-bottom: 15px;
            color: #9ca3af;
        }

        .stats-item {
            margin-bottom: 12px;
            font-size: 13px;
        }

        .bar-container {
            width: 100%;
            height: 12px;
            background: #1a2332;
            border-radius: 4px;
            margin-top: 6px;
            display: flex;
            overflow: hidden;
        }

        .bar-segment {
            height: 100%;
            transition: all 0.3s;
        }

        .bar-segment.mentioned {
            background: #3b82f6;
        }

        .bar-segment.not-mentioned {
            background: #4b5563;
        }

        /* TRANSCRIPTS SECTION - HORIZONTAL GRID */
        .transcripts-section {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(350px, 1fr));
            gap: 15px;
        }

        .transcript-card {
            background: #2d3748;
            border: 1px solid #374151;
            border-radius: 8px;
            padding: 15px;
            transition: all 0.2s;
            display: flex;
            flex-direction: column;
        }

        .transcript-card:hover {
            border-color: #3b82f6;
            transform: translateY(-2px);
        }

        .transcript-title {
            font-size: 14px;
            font-weight: 600;
            color: #f3f4f6;
            margin-bottom: 8px;
            line-height: 1.4;
        }

        .transcript-date {
            font-size: 12px;
            color: #9ca3af;
            margin-bottom: 10px;
        }

        .transcript-totals {
            font-size: 13px;
            margin-bottom: 10px;
            color: #d1d5db;
        }

        .transcript-totals strong {
            color: #3b82f6;
        }

        .transcript-content {
            background: #1a2332;
            padding: 10px;
            border-radius: 4px;
            font-size: 12px;
            line-height: 1.6;
            color: #d1d5db;
            margin-bottom: 10px;
            max-height: 200px;
            overflow-y: auto;
        }

        .transcript-content::-webkit-scrollbar {
            width: 6px;
        }

        .transcript-content::-webkit-scrollbar-track {
            background: #374151;
            border-radius: 3px;
        }

        .transcript-content::-webkit-scrollbar-thumb {
            background: #4b5563;
            border-radius: 3px;
        }

        .highlight {
            background-color: #fbbf24;
            color: #000;
            padding: 2px 4px;
            border-radius: 2px;
            font-weight: 600;
        }

        /* Hit spans for precise marker jumping */
        .hit {
            border-radius: 2px;
            padding: 0 2px;
            font-weight: 600;
            transition: all 0.3s;
        }

        .hit-trump {
            color: #3b82f6;
            background: rgba(59, 130, 246, 0.15);
        }

        .hit-other {
            color: #b45309;
            background: rgba(180, 83, 9, 0.15);
        }

        /* Flash highlight animation */
        .hit-flash-trump {
            outline: 2px solid rgba(59, 130, 246, 0.9);
            background: rgba(59, 130, 246, 0.35);
        }

        .hit-flash-other {
            outline: 2px solid rgba(180, 83, 9, 0.9);
            background: rgba(180, 83, 9, 0.35);
        }

        /* YOUTUBE-STYLE PROGRESS BAR - ONLY MARKERS */
        .progress-bar-container {
            position: relative;
            height: 12px;
            background: #4b5563;
            border-radius: 6px;
            cursor: pointer;
            overflow: visible;
        }

        .progress-bar-container:hover {
            height: 14px;
        }

        .progress-bar-markers {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }

        .progress-marker {
            position: absolute;
            top: 0;
            width: 6px;
            height: 100%;
            background: #3b82f6;
            cursor: pointer;
            transition: all 0.2s;
            border-radius: 2px;
        }

        /* Enlarged hitbox for easier clicking */
        .progress-marker::before {
            content: '';
            position: absolute;
            left: -8px;
            right: -8px;
            top: -8px;
            bottom: -8px;
            cursor: pointer;
        }

        .progress-marker:hover {
            width: 8px;
            height: 120%;
            top: -10%;
            background: #60a5fa;
        }

        .progress-marker.other {
            background: #b45309;
        }

        .progress-marker.other:hover {
            background: #d97706;
        }

        /* STATS BARS - PROPORTIONAL WITH COLOR CODING */
        .stats-bar-item {
            height: 100%;
            cursor: pointer;
            transition: all 0.2s;
            border-right: 1px solid #1a2332;
        }

        .stats-bar-item:hover {
            opacity: 0.8;
            transform: scaleY(1.1);
        }

        .stats-bar-item.mentions-0 {
            background: #4b5563;
        }

        .stats-bar-item.mentions-1-3 {
            background: #60a5fa;
        }

        .stats-bar-item.mentions-3-7 {
            background: #3b82f6;
        }

        .stats-bar-item.mentions-7plus {
            background: #1e40af;
        }

        .speaker-separator {
            height: 15px;
            background: transparent;
        }

        /* Loading & Empty states */
        .loading {
            text-align: center;
            padding: 40px;
            color: #9ca3af;
            grid-column: 1 / -1;
        }

        .empty-state {
            text-align: center;
            padding: 60px 20px;
            color: #9ca3af;
            grid-column: 1 / -1;
        }

        .empty-state h3 {
            font-size: 18px;
            margin-bottom: 10px;
        }

        /* Scrollbar styling */
        .filter-items::-webkit-scrollbar {
            width: 6px;
        }

        .filter-items::-webkit-scrollbar-track {
            background: #374151;
            border-radius: 3px;
        }

        .filter-items::-webkit-scrollbar-thumb {
            background: #4b5563;
            border-radius: 3px;
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- SEARCH SECTION -->
        <div class="search-section">
            <div class="search-title">MentionMarkets.com</div>
            <div style="position: relative;">
                <input type="text" class="search-input" id="searchInput" placeholder="Search terms (e.g., trump derangement syndrome)" style="padding-right: 45px;">
                <button id="searchBtn" onclick="performSearch()" style="
                    position: absolute;
                    right: 5px;
                    top: 50%;
                    transform: translateY(-50%);
                    background: linear-gradient(135deg, #3b82f6 0%, #2563eb 100%);
                    border: none;
                    border-radius: 4px;
                    padding: 8px 12px;
                    cursor: pointer;
                    color: white;
                    font-size: 16px;
                    transition: all 0.2s;
                ">üîç</button>
            </div>

            <div class="search-options">
                <div class="search-option">
                    <input type="checkbox" id="matchBeginning" checked>
                    <label for="matchBeginning">Match Beginning</label>
                </div>
                <div class="search-option">
                    <input type="checkbox" id="matchEnding" checked>
                    <label for="matchEnding">Match Ending</label>
                </div>
                <div class="search-option">
                    <input type="checkbox" id="includePlural" checked>
                    <label for="includePlural">Include Plural/Possessive</label>
                </div>
                <div class="search-option">
                    <input type="checkbox" id="includeHyphenation" checked>
                    <label for="includeHyphenation">Include Hyphenation</label>
                </div>
                <div class="search-option">
                    <input type="checkbox" id="caseSensitive">
                    <label for="caseSensitive">Case-Sensitive</label>
                </div>
            </div>

            <div class="options-row">
                <span class="option-label">Context Size:</span>
                <input type="number" class="context-size-input" id="contextSize" value="200" min="50" max="500">

                <span class="option-label" style="margin-left: 20px;">Sort Results:</span>
                <select class="sort-select" id="sortSelect">
                    <option value="newest">Newest</option>
                    <option value="oldest">Oldest</option>
                    <option value="most-mentions">Most Mentions</option>
                </select>

                <div class="checkbox-group" style="margin-left: auto;">
                    <input type="checkbox" id="showResults" checked>
                    <label for="showResults">Show Results</label>
                </div>
                <div class="checkbox-group">
                    <input type="checkbox" id="showMatchLocations" checked>
                    <label for="showMatchLocations">Show Match Locations</label>
                </div>
                <div class="checkbox-group">
                    <input type="checkbox" id="showContext" checked>
                    <label for="showContext">Show Context</label>
                </div>
                <div class="checkbox-group">
                    <input type="checkbox" id="debugMode">
                    <label for="debugMode" style="color: #fbbf24;">üîç Debug Mode</label>
                </div>
            </div>
        </div>

        <!-- CHARTS SECTION -->
        <div class="charts-container">
            <div class="chart-wrapper">
                <div class="chart-title">Mentions Over Time</div>
                <canvas id="mentionsChart" class="chart-canvas"></canvas>
            </div>
            <div class="chart-wrapper">
                <div class="chart-title">Location in Event (from Start to Finish)</div>
                <canvas id="locationChart" class="chart-canvas"></canvas>
            </div>
        </div>

        <!-- FILTERS SECTION - HORIZONTAL -->
        <div class="filters-section">
            <div class="filters-title">Filters</div>
            <div class="filters-grid">
                <!-- Date Range -->
                <div class="filter-group">
                    <div class="filter-group-title">Date Range</div>
                    <label style="font-size: 12px; margin-bottom: 5px; color: #9ca3af;">Start Date</label>
                    <input type="date" class="date-input" id="startDate" value="2016-01-01">
                    <label style="font-size: 12px; margin-top: 8px; margin-bottom: 5px; color: #9ca3af;">End Date</label>
                    <input type="date" class="date-input" id="endDate" value="2025-12-31">
                </div>

                <!-- Minimum Word Count -->
                <div class="filter-group">
                    <div class="filter-group-title">Minimum Word Count</div>
                    <label style="font-size: 12px; margin-bottom: 5px; color: #9ca3af;">Exclude transcripts shorter than:</label>
                    <input type="number" class="date-input" id="minWordCount" value="500" min="0" step="100" placeholder="e.g., 500">
                    <div style="font-size: 11px; color: #6b7280; margin-top: 5px;">
                        Filters out brief remarks and short gaggles
                    </div>
                </div>

                <!-- Categories -->
                <div class="filter-group">
                    <div class="filter-group-title">Categories</div>
                    <div class="filter-buttons">
                        <button class="filter-btn" onclick="selectAllCategories()">All</button>
                        <button class="filter-btn secondary" onclick="selectNoneCategories()">None</button>
                    </div>
                    <div class="filter-items" id="categoriesFilter">
                        <!-- Populated dynamically -->
                    </div>
                </div>

                <!-- Speakers -->
                <div class="filter-group">
                    <div class="filter-group-title">Speakers</div>
                    <input type="text" id="speakerSearch" placeholder="Search speakers..." onkeyup="filterSpeakers()" style="
                        width: 100%;
                        padding: 8px;
                        background: #1a2332;
                        border: 1px solid #374151;
                        border-radius: 4px;
                        color: #e5e7eb;
                        font-size: 13px;
                        margin-bottom: 10px;
                    ">
                    <div class="filter-buttons">
                        <button class="filter-btn" onclick="selectAllSpeakers()">All</button>
                        <button class="filter-btn secondary" onclick="selectNoneSpeakers()">None</button>
                    </div>
                    <div class="filter-items" id="speakersFilter" style="max-height: 200px; overflow-y: auto;">
                        <!-- Populated dynamically -->
                    </div>
                </div>

                <!-- Events -->
                <div class="filter-group">
                    <div class="filter-group-title">Events</div>
                    <div class="filter-buttons">
                        <button class="filter-btn" onclick="selectAllEvents()">All</button>
                        <button class="filter-btn secondary" onclick="selectNoneEvents()">None</button>
                    </div>
                    <div class="filter-items" id="eventsFilter">
                        <!-- Populated dynamically -->
                    </div>
                </div>
            </div>

            <!-- Apply Filters Button -->
            <div style="margin-top: 15px; text-align: center;">
                <button id="applyFiltersBtn" onclick="applyFilters()" style="
                    padding: 12px 32px;
                    background: linear-gradient(135deg, #3b82f6 0%, #2563eb 100%);
                    color: white;
                    border: none;
                    border-radius: 6px;
                    font-size: 14px;
                    font-weight: 600;
                    cursor: pointer;
                    transition: all 0.2s;
                    box-shadow: 0 2px 8px rgba(59, 130, 246, 0.3);
                ">
                    Apply Filters
                </button>
            </div>
        </div>

        <!-- STATISTICS SECTION -->
        <div class="stats-section" id="statsSection" style="display: none;">
            <div class="stats-title">Statistics</div>
            <div class="stats-item">
                <span id="eventPercentage">0.0%</span> of events have at least <span id="minMentions">3</span> mentions.
            </div>
            <div class="stats-item">
                Monthly matches: <span id="monthlyMatches">0.0%</span>
                <div class="bar-container" id="monthlyBar"></div>
            </div>
            <div class="stats-item">
                Weekly matches: <span id="weeklyMatches">0.0%</span>
                <div class="bar-container" id="weeklyBar"></div>
            </div>
        </div>

        <!-- TRANSCRIPTS SECTION - HORIZONTAL GRID -->
        <div class="transcripts-section" id="transcriptsSection">
            <div class="loading">Loading transcripts...</div>
        </div>
    </div>

    <script>
        let mentionsChart = null;
        let locationChart = null;
        let allTranscripts = [];
        let transcriptsData = [];

        // Initialize charts
        function initCharts() {
            const mentionsCtx = document.getElementById('mentionsChart').getContext('2d');
            const locationCtx = document.getElementById('locationChart').getContext('2d');

            // SCATTER/DOT CHART for mentions over time
            mentionsChart = new Chart(mentionsCtx, {
                type: 'scatter',
                data: {
                    datasets: [{
                        label: 'Mentions',
                        data: [],
                        backgroundColor: '#3b82f6',
                        borderColor: '#3b82f6',
                        pointRadius: 6,
                        pointHoverRadius: 8
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    onClick: (event, elements) => {
                        if (elements.length > 0) {
                            const dataIndex = elements[0].index;
                            const dataset = mentionsChart.data.datasets[0];
                            const point = dataset.data[dataIndex];
                            if (point && point.transcriptId) {
                                const card = document.getElementById(`card-${point.transcriptId}`);
                                if (card) {
                                    card.scrollIntoView({ behavior: 'smooth', block: 'center' });
                                    card.style.border = '2px solid #3b82f6';
                                    setTimeout(() => { card.style.border = '1px solid #374151'; }, 2000);
                                }
                            }
                        }
                    },
                    plugins: {
                        legend: { display: false },
                        tooltip: {
                            backgroundColor: '#1a2332',
                            titleColor: '#f3f4f6',
                            bodyColor: '#d1d5db',
                            borderColor: '#374151',
                            borderWidth: 1,
                            callbacks: {
                                label: function(context) {
                                    const point = context.dataset.data[context.dataIndex];
                                    const transcript = transcriptsData.find(t => t.id === point.transcriptId);
                                    const title = transcript ? transcript.title.substring(0, 50) : 'Unknown';
                                    return [
                                        `${context.parsed.y} mentions`,
                                        `${title}${transcript && transcript.title.length > 50 ? '...' : ''}`
                                    ];
                                }
                            }
                        }
                    },
                    scales: {
                        x: {
                            type: 'category',
                            grid: { color: '#374151' },
                            ticks: {
                                color: '#9ca3af',
                                font: { size: 10 },
                                maxRotation: 45,
                                minRotation: 45
                            },
                            title: {
                                display: true,
                                text: 'Event Date',
                                color: '#9ca3af'
                            }
                        },
                        y: {
                            grid: { color: '#374151' },
                            ticks: {
                                color: '#9ca3af',
                                font: { size: 11 },
                                stepSize: 1
                            },
                            beginAtZero: true,
                            title: {
                                display: true,
                                text: 'Mentions',
                                color: '#9ca3af'
                            }
                        }
                    }
                }
            });

            // STEPPED LINE CHART for location (cumulative %)
            locationChart = new Chart(locationCtx, {
                type: 'line',
                data: {
                    labels: [],
                    datasets: [{
                        label: 'All Mentions',
                        data: [],
                        borderColor: '#60a5fa',
                        backgroundColor: 'rgba(96, 165, 250, 0.1)',
                        stepped: true,
                        fill: true,
                        pointRadius: 0,
                        borderWidth: 2
                    }, {
                        label: 'First Mentions',
                        data: [],
                        borderColor: '#fbbf24',
                        backgroundColor: 'rgba(251, 191, 36, 0.1)',
                        stepped: true,
                        fill: true,
                        pointRadius: 0,
                        borderWidth: 2
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            display: true,
                            position: 'top',
                            labels: { color: '#d1d5db', font: { size: 11 } }
                        },
                        tooltip: {
                            backgroundColor: '#1a2332',
                            titleColor: '#f3f4f6',
                            bodyColor: '#d1d5db',
                            borderColor: '#374151',
                            borderWidth: 1
                        }
                    },
                    scales: {
                        x: {
                            grid: { color: '#374151' },
                            ticks: {
                                color: '#9ca3af',
                                font: { size: 10 },
                                callback: function(value, index) {
                                    // Show every 10th label
                                    return index % 10 === 0 ? this.getLabelForValue(value) : '';
                                }
                            },
                            title: {
                                display: true,
                                text: 'Time in Speech',
                                color: '#9ca3af',
                                font: { size: 11 }
                            }
                        },
                        y: {
                            grid: { color: '#374151' },
                            ticks: { color: '#9ca3af', font: { size: 11 } },
                            min: 0,
                            max: 100,
                            title: {
                                display: true,
                                text: 'Cumulative Percent',
                                color: '#9ca3af'
                            }
                        }
                    }
                }
            });
        }

        // Load initial data
        async function loadInitialData() {
            try {
                // Get unique speech types from data
                const speechTypes = [...new Set(transcriptsData.map(t => t.speech_type))].sort();

                // Populate categories
                const categoriesFilter = document.getElementById('categoriesFilter');
                categoriesFilter.innerHTML = speechTypes.map((type, idx) => `
                    <div class="filter-item">
                        <input type="checkbox" id="cat-${idx}" value="${type}" checked>
                        <label for="cat-${idx}">${type}</label>
                    </div>
                `).join('');

                // Get all unique speakers from transcripts and count frequency
                const speakerCounts = {};
                transcriptsData.forEach(t => {
                    if (t.speakers && Array.isArray(t.speakers)) {
                        t.speakers.forEach(speaker => {
                            speakerCounts[speaker] = (speakerCounts[speaker] || 0) + 1;
                        });
                    }
                });

                // Sort by frequency (most frequent first)
                const uniqueSpeakers = Object.keys(speakerCounts).sort((a, b) => {
                    return speakerCounts[b] - speakerCounts[a];
                });

                // Populate speakers filter
                const speakersFilter = document.getElementById('speakersFilter');
                console.log('Found speakers:', uniqueSpeakers.length, uniqueSpeakers.slice(0, 5));

                if (uniqueSpeakers.length > 0) {
                    speakersFilter.innerHTML = uniqueSpeakers.map((speaker, idx) => `
                        <div class="filter-item">
                            <input type="checkbox" id="speaker-${idx}" value="${speaker}" checked>
                            <label for="speaker-${idx}">${speaker} <span style="color: #6b7280; font-size: 11px;">(${speakerCounts[speaker]})</span></label>
                        </div>
                    `).join('');
                } else {
                    speakersFilter.innerHTML = '<div style="padding: 10px; color: #9ca3af;">No speakers found</div>';
                }

                // Get recent transcripts (last 20)
                allTranscripts = transcriptsData
                    .sort((a, b) => new Date(b.date) - new Date(a.date))
                    .slice(0, 20);

                // Populate events
                const eventsFilter = document.getElementById('eventsFilter');
                eventsFilter.innerHTML = allTranscripts.map((t, idx) => `
                    <div class="filter-item">
                        <input type="checkbox" id="event-${idx}" value="${t.id}" checked>
                        <label for="event-${idx}" title="${t.title}">${t.title.substring(0, 60)}${t.title.length > 60 ? '...' : ''}</label>
                    </div>
                `).join('');

                displayTranscripts(allTranscripts);

                // Update stats display
                const latestDate = transcriptsData
                    .map(t => t.date)
                    .filter(d => d)
                    .sort((a, b) => new Date(b) - new Date(a))[0] || 'N/A';

                document.querySelector('.search-section').insertAdjacentHTML('afterbegin', `
                    <div style="margin-bottom: 15px; padding: 10px; background: rgba(59, 130, 246, 0.1); border-radius: 6px; font-size: 13px;">
                        üìä <strong>${transcriptsData.length}</strong> transcripts loaded | Latest: ${latestDate}
                    </div>
                `);

            } catch (error) {
                console.error('Error loading data:', error);
                document.getElementById('transcriptsSection').innerHTML = '<div class="empty-state"><h3>Error loading data</h3><p>Try refreshing the page.</p></div>';
            }
        }

        // Display transcripts in horizontal grid
        function displayTranscripts(transcripts) {
            console.log('displayTranscripts called with', transcripts.length, 'transcripts');
            const container = document.getElementById('transcriptsSection');
            console.log('Container element:', container);
            const isSearching = document.getElementById('searchInput').value.trim().length > 0;

            if (transcripts.length === 0) {
                container.innerHTML = '<div class="empty-state"><h3>No transcripts found</h3><p>Try adjusting your search or filters.</p></div>';
                return;
            }

            console.log('Generating HTML for transcripts...');
            container.innerHTML = transcripts.map(t => {
                const mentionCount = t.mention_count || 0;
                const mentions = t.mentions || [];
                const mentionLocations = t.mention_locations || [];

                // Get all speakers who mentioned the term
                let totalsHTML = '';
                if (mentionCount > 0) {
                    const speakerCounts = {'Donald Trump': mentionCount};
                    const speakersStr = Object.entries(speakerCounts)
                        .map(([speaker, count]) => `${speaker}: ${count}`)
                        .join(', ');
                    totalsHTML = `<div class="transcript-totals"><strong>Totals:</strong> ${speakersStr}</div>`;
                }

                // Context is now handled by "Show Full Transcript" - no separate context box needed
                let contentHTML = '';

                // Create YouTube-style progress bar with blue (Trump) and brown (other) markers
                // Now using Trump-only, word-based locations (0..1 normalized)
                let progressBarHTML = '';
                const showMarkers = document.getElementById('showMatchLocations').checked;
                const hasMarkers = (mentionLocations.length > 0) || ((t.other_mention_locations || []).length > 0);
                
                if (hasMarkers && showMarkers) {
                    // Blue markers for Trump mentions (now word-index based)
                    const blueMarkersHTML = mentionLocations.map((loc, idx) =>
                        `<div class="progress-marker" style="left: ${loc.location * 100}%;" title="Trump: ${(loc.location * 100).toFixed(1)}% (word ${loc.position_word || 0})" onclick="seekToMention(event, ${t.id}, ${loc.position_word || loc.char_pos || 0}, 'trump', ${idx})"></div>`
                    ).join('');

                    // Brown markers for other speaker mentions (still char-based for backward compat)
                    const brownMarkersHTML = (t.other_mention_locations || []).map((loc, idx) =>
                        `<div class="progress-marker other" style="left: ${loc.location * 100}%;" title="Other: ${(loc.location * 100).toFixed(1)}%" onclick="seekToMention(event, ${t.id}, ${loc.position}, 'other', ${idx})"></div>`
                    ).join('');

                    progressBarHTML = `
                        <div class="progress-bar-container" onclick="seekInTranscript(event, ${t.id})">
                            <div class="progress-bar-markers">${blueMarkersHTML}${brownMarkersHTML}</div>
                        </div>
                    `;
                }

                // FULL TRANSCRIPT - Render with structured turns and proper highlighting with hit spans
                let previewText = '';
                const hasPreview = t.preview && t.preview.length > 0;

                if (hasPreview) {
                    const { turns } = parseTranscriptTurns(t.preview);
                    const searchTerms = isSearching && mentionCount > 0 
                        ? document.getElementById('searchInput').value.toLowerCase().split(',').map(s => s.trim()).filter(s => s)
                        : [];

                    // Build HTML from turns with position tracking
                    let currentOffset = 0; // Track position in original preview string
                    const originalLines = t.preview.split('\n');
                    let lineIdx = 0;

                    turns.forEach(turn => {
                        const isTrump = turn.speaker === 'Donald Trump';
                        
                        // Add speaker label (never highlighted)
                        previewText += `<strong>${turn.speaker.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;')}:</strong><br>`;
                        
                        // Skip speaker line in original
                        if (lineIdx < originalLines.length) {
                            currentOffset += originalLines[lineIdx].length + 1; // +1 for \n
                            lineIdx++;
                        }

                        // Process dialogue lines
                        turn.dialogueLines.forEach((line, dialogueLineIdx) => {
                            // Escape HTML first
                            let escapedLine = line
                                .replace(/&/g, '&amp;')
                                .replace(/</g, '&lt;')
                                .replace(/>/g, '&gt;');

                            // Apply highlighting with hit spans if searching
                            if (searchTerms.length > 0) {
                                const hitClass = isTrump ? 'hit-trump' : 'hit-other';
                                const matchType = isTrump ? 'trump' : 'other';
                                
                                searchTerms.forEach(term => {
                                    const escapedTerm = term.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
                                    
                                    // Find all matches in this line with positions
                                    const lineLower = line.toLowerCase();
                                    let pos = 0;
                                    const replacements = [];
                                    
                                    while ((pos = lineLower.indexOf(term, pos)) !== -1) {
                                        const absPos = currentOffset + pos;
                                        replacements.push({
                                            start: pos,
                                            end: pos + term.length,
                                            absPos: absPos
                                        });
                                        pos += term.length;
                                    }

                                    // Apply replacements in reverse order to maintain positions
                                    replacements.reverse().forEach(repl => {
                                        const before = escapedLine.substring(0, repl.start);
                                        const match = escapedLine.substring(repl.start, repl.end);
                                        const after = escapedLine.substring(repl.end);
                                        escapedLine = before + 
                                            `<span class="hit ${hitClass}" data-abspos="${repl.absPos}" data-type="${matchType}">${match}</span>` + 
                                            after;
                                    });
                                });
                            }

                            previewText += escapedLine + '<br>';
                            
                            // Update offset for next line
                            if (lineIdx < originalLines.length) {
                                currentOffset += originalLines[lineIdx].length + 1;
                                lineIdx++;
                            }
                        });
                    });
                }

                // Build debug info panel if debug mode is enabled
                let debugHTML = '';
                const debugMode = document.getElementById('debugMode') && document.getElementById('debugMode').checked;
                if (debugMode) {
                    const firstMentionLoc = mentionLocations.length > 0 ? mentionLocations[0].location : null;
                    const debugStyle = mentionCount > 0 ? 'background: rgba(34, 197, 94, 0.1); border-left: 3px solid #22c55e;' : 'background: rgba(239, 68, 68, 0.1); border-left: 3px solid #ef4444;';
                    
                    debugHTML = `
                        <div class="debug-panel" style="
                            ${debugStyle}
                            padding: 8px 12px;
                            margin: 8px 0;
                            font-size: 11px;
                            font-family: 'Courier New', monospace;
                            border-radius: 4px;
                        ">
                            <div style="color: #fbbf24; font-weight: 600; margin-bottom: 4px;">üîç DEBUG INFO</div>
                            <div style="color: #e5e7eb;">
                                <div>üìä <strong>Computed mention_count:</strong> ${mentionCount}</div>
                                <div>üéØ <strong>Rendered .hit-trump spans:</strong> <span id="debug-hit-count-${t.id}">calculating...</span></div>
                                <div>üìà <strong>Dot plot Y-value:</strong> <span id="debug-chart-value-${t.id}">calculating...</span></div>
                                ${firstMentionLoc !== null ? `<div>üìç <strong>First mention location:</strong> ${(firstMentionLoc * 100).toFixed(1)}%</div>` : ''}
                                ${mentionCount > 0 && mentionLocations.length === 0 ? '<div style="color: #ef4444;">‚ö†Ô∏è MISMATCH: Has count but no locations!</div>' : ''}
                            </div>
                        </div>
                    `;
                }

                return `
                    <div class="transcript-card" id="card-${t.id}" data-date="${t.date}" data-mention-count="${mentionCount}">
                        <div class="transcript-title">${t.title}</div>
                        <div class="transcript-date">${t.date} | ${t.speech_type}${t.location ? ' | ' + t.location : ''}</div>
                        ${totalsHTML}
                        ${debugHTML}
                        ${hasPreview ? `
                            <div class="preview-toggle" onclick="togglePreview(${t.id})" style="
                                cursor: pointer;
                                color: #3b82f6;
                                font-size: 13px;
                                margin-top: 8px;
                                user-select: none;
                                font-weight: 600;
                            ">
                                <span id="preview-icon-${t.id}">‚ñ∂</span> Show Full Transcript
                            </div>
                            <div id="preview-${t.id}" style="
                                display: none;
                                margin-top: 10px;
                                padding: 15px;
                                background: rgba(0, 0, 0, 0.3);
                                border-radius: 6px;
                                font-size: 13px;
                                line-height: 1.7;
                                color: #e5e7eb;
                                max-height: 600px;
                                overflow-y: auto;
                                border: 1px solid #374151;
                            ">${previewText}</div>
                        ` : ''}
                        ${contentHTML && document.getElementById('showContext').checked ? `
                            <div class="transcript-content" id="content-${t.id}">${contentHTML}</div>
                        ` : ''}
                        ${progressBarHTML}
                    </div>
                `;
            }).join('');

            // After rendering, populate debug information if debug mode is enabled
            const debugMode = document.getElementById('debugMode') && document.getElementById('debugMode').checked;
            if (debugMode) {
                // Use setTimeout to ensure DOM is updated
                setTimeout(() => {
                    transcripts.forEach(t => {
                        // Count actual rendered .hit-trump spans
                        const previewEl = document.getElementById(`preview-${t.id}`);
                        if (previewEl) {
                            const hitCount = previewEl.querySelectorAll('.hit-trump').length;
                            const hitCountEl = document.getElementById(`debug-hit-count-${t.id}`);
                            if (hitCountEl) {
                                const expectedCount = t.mention_count || 0;
                                const match = hitCount === expectedCount;
                                hitCountEl.innerHTML = `${hitCount}${match ? ' ‚úì' : ` <span style="color: #ef4444;">‚ö†Ô∏è Expected ${expectedCount}</span>`}`;
                            }
                        }

                        // Get dot plot value from chart data
                        const chartValueEl = document.getElementById(`debug-chart-value-${t.id}`);
                        if (chartValueEl && mentionsChart && mentionsChart.data.datasets[0].data) {
                            const dataPoint = mentionsChart.data.datasets[0].data.find(d => d.transcriptId === t.id);
                            if (dataPoint) {
                                const chartValue = dataPoint.y;
                                const expectedValue = t.mention_count || 0;
                                const match = chartValue === expectedValue;
                                chartValueEl.innerHTML = `${chartValue}${match ? ' ‚úì' : ` <span style="color: #ef4444;">‚ö†Ô∏è Expected ${expectedValue}</span>`}`;
                                
                                // Log mismatch to console for debugging
                                if (!match) {
                                    console.error(`üî¥ MISMATCH for transcript ${t.id}:`, {
                                        title: t.title,
                                        date: t.date,
                                        mention_count: t.mention_count,
                                        chart_y_value: chartValue,
                                        debug: t._match_debug
                                    });
                                }
                            } else {
                                chartValueEl.innerHTML = '<span style="color: #ef4444;">Not in chart!</span>';
                            }
                        }
                    });
                }, 100);
            }
        }

        // Perform search
        async function performSearch() {
            const searchBtn = document.getElementById('searchBtn');
            const searchInput = document.getElementById('searchInput').value.trim();

            // Visual feedback - show loading
            searchBtn.textContent = '‚è≥';
            searchBtn.style.background = 'linear-gradient(135deg, #f59e0b 0%, #d97706 100%)';

            if (!searchInput) {
                // Apply current filters
                applyFilters();
                document.getElementById('statsSection').style.display = 'none';

                // Clear charts
                mentionsChart.data.datasets[0].data = [];
                mentionsChart.update();
                locationChart.data.labels = [];
                locationChart.data.datasets[0].data = [];
                locationChart.data.datasets[1].data = [];
                locationChart.update();

                // Reset button
                searchBtn.textContent = 'üîç';
                searchBtn.style.background = 'linear-gradient(135deg, #3b82f6 0%, #2563eb 100%)';
                return;
            }

            // Simulate async for smooth UX
            await new Promise(resolve => setTimeout(resolve, 100));

            const terms = searchInput.toLowerCase().split(',').map(t => t.trim()).filter(t => t);
            const startDate = new Date(document.getElementById('startDate').value);
            const endDate = new Date(document.getElementById('endDate').value);
            const minWordCount = parseInt(document.getElementById('minWordCount').value) || 0;
            const selectedCategories = Array.from(document.querySelectorAll('#categoriesFilter input:checked')).map(cb => cb.value);

            try {
                console.log('Searching for:', terms);
                console.log('Date range:', startDate, 'to', endDate);
                console.log('Min word count:', minWordCount);
                console.log('Categories:', selectedCategories);
                console.log('Total transcripts to search:', transcriptsData.length);

                // Client-side search using UNIFIED Trump-only match computation
                const results = transcriptsData.filter(t => {
                    // Filter by date and category
                    const tDate = new Date(t.date);
                    if (tDate < startDate || tDate > endDate) return false;
                    if (!selectedCategories.includes(t.speech_type)) return false;

                    // Filter by minimum word count
                    if ((t.word_count || 0) < minWordCount) return false;

                    // Use unified match computation to check for matches
                    const preview = t.preview || '';
                    const matchData = computeTrumpMatches(preview, terms);
                    
                    return matchData.mention_count > 0;
                }).map(t => {
                    // Calculate mention_count and mention_locations using UNIFIED helper
                    const preview = t.preview || '';
                    const matchData = computeTrumpMatches(preview, terms);
                    
                    // Also compute other speaker mentions for brown markers (backward compat)
                    const { turns, totalLength } = parseTranscriptTurns(preview);
                    const otherMentionLocations = [];
                    let otherMentionCount = 0;

                    // Process non-Trump turns for brown markers
                    turns.forEach(turn => {
                        const dialogue = turn.dialogueLines.join('\n');
                        const dialogueLower = dialogue.toLowerCase();
                        const isTrump = turn.speaker === 'Donald Trump';

                        if (!isTrump) {
                            // Find all term matches in other speakers' dialogue
                            terms.forEach(term => {
                                let pos = 0;
                                while ((pos = dialogueLower.indexOf(term, pos)) !== -1) {
                                    const absolutePos = turn.dialogueStartOffset + pos;
                                    const location = absolutePos / totalLength;
                                    
                                    otherMentionCount++;
                                    otherMentionLocations.push({
                                        location: location,
                                        position: absolutePos
                                    });

                                    pos += term.length;
                                }
                            });
                        }
                    });

                    // Build context snippets from Trump's dialogue
                    const mentions = [];
                    if (matchData.mention_count > 0) {
                        mentions.push({
                            context: matchData.trump_only_text.substring(0, 500),
                            highlight_start: 0,
                            highlight_end: 0
                        });
                    }

                    return {
                        ...t,
                        mention_count: matchData.mention_count,
                        mentions: mentions,
                        mention_locations: matchData.mention_locations,
                        other_mention_locations: otherMentionLocations,
                        other_mention_count: otherMentionCount,
                        _match_debug: matchData.debug  // Store debug info
                    };
                });

                console.log('Found results:', results.length);

                // Sort by date descending
                results.sort((a, b) => new Date(b.date) - new Date(a.date));

                // Display results
                displayTranscripts(results);

                // Update charts with search results
                updateMentionsChart(results);
                updateLocationChart(results);

                // Show message if no results
                if (results.length === 0) {
                    document.getElementById('transcriptsSection').innerHTML = `
                        <div class="empty-state">
                            <h3>No results found for "${searchInput}"</h3>
                            <p>Try different keywords or adjust your filters</p>
                            <p style="font-size: 12px; color: #6b7280; margin-top: 10px;">
                                Searched in ${transcriptsData.length} transcripts from ${startDate.toISOString().split('T')[0]} to ${endDate.toISOString().split('T')[0]}
                            </p>
                        </div>
                    `;
                }

                // Show success feedback
                searchBtn.textContent = '‚úì';
                searchBtn.style.background = 'linear-gradient(135deg, #10b981 0%, #059669 100%)';

                // Reset button after 1 second
                setTimeout(() => {
                    searchBtn.textContent = 'üîç';
                    searchBtn.style.background = 'linear-gradient(135deg, #3b82f6 0%, #2563eb 100%)';
                }, 1000);

            } catch (error) {
                console.error('Search error:', error);
                searchBtn.textContent = '‚úó';
                searchBtn.style.background = 'linear-gradient(135deg, #ef4444 0%, #dc2626 100%)';

                setTimeout(() => {
                    searchBtn.textContent = 'üîç';
                    searchBtn.style.background = 'linear-gradient(135deg, #3b82f6 0%, #2563eb 100%)';
                }, 2000);
            }
        }

        // Update mentions DOT chart - REFACTORED to avoid date-bucketing bugs
        function updateMentionsChart(results) {
            // Get current date range from filters
            const startDate = new Date(document.getElementById('startDate').value);
            const endDate = new Date(document.getElementById('endDate').value);
            const minWordCount = parseInt(document.getElementById('minWordCount').value) || 0;
            const selectedCategories = Array.from(document.querySelectorAll('#categoriesFilter input:checked')).map(cb => cb.value);

            console.log('Chart date range:', startDate, 'to', endDate);

            // Get ALL transcripts within date range (from original data, not just search results)
            const allTranscriptsInRange = transcriptsData.filter(t => {
                const tDate = new Date(t.date);
                const inDateRange = tDate >= startDate && tDate <= endDate;
                const inCategory = selectedCategories.includes(t.speech_type);
                const meetsMinWordCount = (t.word_count || 0) >= minWordCount;
                return inDateRange && inCategory && meetsMinWordCount;
            });

            console.log('All transcripts in range:', allTranscriptsInRange.length);
            console.log('Search results with matches:', results.length);

            // Create a lookup map for results by transcript ID for O(1) access
            const resultsById = new Map();
            results.forEach(r => {
                resultsById.set(r.id, r);
            });

            // Build data array by iterating over ALL transcripts in range
            // This ensures no transcript is lost due to date-bucketing issues
            const data = [];
            allTranscriptsInRange.forEach(t => {
                const resultData = resultsById.get(t.id);
                const mentionCount = resultData ? (resultData.mention_count || 0) : 0;
                
                data.push({
                    x: t.date,
                    y: mentionCount,
                    transcriptId: t.id,
                    title: t.title,
                    _debug_in_results: !!resultData,
                    _debug_count_source: resultData ? 'from_results' : 'zero_default'
                });
            });

            // Sort by date
            data.sort((a, b) => new Date(a.x) - new Date(b.x));

            console.log('Chart data points:', data.length);
            console.log('Points with matches:', data.filter(d => d.y > 0).length);
            console.log('Points at zero:', data.filter(d => d.y === 0).length);

            mentionsChart.data.datasets[0].data = data;
            mentionsChart.update();
        }

        // Update location chart - now using Trump-only, word-based locations from computeTrumpMatches
        function updateLocationChart(results) {
            const allLocations = [];
            const firstMentionLocations = [];

            // Extract locations (now Trump-only, word-based normalized to 0..1)
            results.forEach(r => {
                if (r.mention_locations && r.mention_locations.length > 0) {
                    r.mention_locations.forEach(loc => allLocations.push(loc.location));
                    firstMentionLocations.push(Math.min(...r.mention_locations.map(l => l.location)));
                }
            });

            if (allLocations.length === 0) {
                locationChart.data.labels = [];
                locationChart.data.datasets[0].data = [];
                locationChart.data.datasets[1].data = [];
                locationChart.update();
                return;
            }

            allLocations.sort((a, b) => a - b);
            firstMentionLocations.sort((a, b) => a - b);

            // Build cumulative distribution (0% to 100% through speech)
            const labels = [];
            const cumulativeData = [];
            const firstMentionData = [];

            for (let i = 0; i <= 1.0; i += 0.01) {
                labels.push(i.toFixed(2));
                cumulativeData.push((allLocations.filter(loc => loc <= i).length / allLocations.length) * 100);
                firstMentionData.push((firstMentionLocations.filter(loc => loc <= i).length / firstMentionLocations.length) * 100);
            }

            locationChart.data.labels = labels;
            locationChart.data.datasets[0].data = cumulativeData;
            locationChart.data.datasets[1].data = firstMentionData;
            locationChart.update();
        }

        // Update statistics with proportional, color-coded bars
        function updateStats(results, timeline) {
            if (results.length === 0) {
                document.getElementById('statsSection').style.display = 'none';
                return;
            }

            document.getElementById('statsSection').style.display = 'block';

            const eventsWithMentions = results.filter(r => r.mention_count >= 3).length;
            const eventPercentage = ((eventsWithMentions / results.length) * 100).toFixed(1);
            document.getElementById('eventPercentage').textContent = eventPercentage + '%';

            // Get current month from most recent result
            const latestDate = new Date(Math.max(...results.map(r => new Date(r.date))));
            const currentMonth = `${latestDate.getFullYear()}-${String(latestDate.getMonth() + 1).padStart(2, '0')}`;

            // Filter transcripts for current month only
            const currentMonthTranscripts = results.filter(r => r.date.startsWith(currentMonth));

            if (currentMonthTranscripts.length > 0) {
                const totalWordCount = currentMonthTranscripts.reduce((sum, r) => sum + (r.word_count || 0), 0);

                const monthlyBar = document.getElementById('monthlyBar');
                monthlyBar.innerHTML = currentMonthTranscripts.map(t => {
                    const widthPercent = (t.word_count / totalWordCount) * 100;
                    const mentions = t.mention_count || 0;

                    let colorClass = 'mentions-0';
                    if (mentions > 7) colorClass = 'mentions-7plus';
                    else if (mentions > 3) colorClass = 'mentions-3-7';
                    else if (mentions > 0) colorClass = 'mentions-1-3';

                    return `<div class="stats-bar-item ${colorClass}"
                        style="flex: ${widthPercent};"
                        title="${t.date}: ${mentions} mentions"
                        onclick="scrollToTranscript(${t.id})"></div>`;
                }).join('');

                const eventsWithMentions = currentMonthTranscripts.filter(t => t.mention_count > 0).length;
                const monthlyPercentage = ((eventsWithMentions / currentMonthTranscripts.length) * 100).toFixed(1);
                document.getElementById('monthlyMatches').textContent = monthlyPercentage + '%';
            }

            // Get current week from most recent result
            const currentWeekNum = getWeekNumber(latestDate);
            const currentWeek = `${latestDate.getFullYear()}-W${String(currentWeekNum).padStart(2, '0')}`;

            // Filter transcripts for current week only
            const currentWeekTranscripts = results.filter(r => {
                const date = new Date(r.date);
                const week = `${date.getFullYear()}-W${String(getWeekNumber(date)).padStart(2, '0')}`;
                return week === currentWeek;
            });

            if (currentWeekTranscripts.length > 0) {
                const totalWeekWordCount = currentWeekTranscripts.reduce((sum, r) => sum + (r.word_count || 0), 0);

                const weeklyBar = document.getElementById('weeklyBar');
                weeklyBar.innerHTML = currentWeekTranscripts.map(t => {
                    const widthPercent = (t.word_count / totalWeekWordCount) * 100;
                    const mentions = t.mention_count || 0;

                    let colorClass = 'mentions-0';
                    if (mentions > 7) colorClass = 'mentions-7plus';
                    else if (mentions > 3) colorClass = 'mentions-3-7';
                    else if (mentions > 0) colorClass = 'mentions-1-3';

                    return `<div class="stats-bar-item ${colorClass}"
                        style="flex: ${widthPercent};"
                        title="${t.date}: ${mentions} mentions"
                        onclick="scrollToTranscript(${t.id})"></div>`;
                }).join('');

                const eventsWithMentions = currentWeekTranscripts.filter(t => t.mention_count > 0).length;
                const weeklyPercentage = ((eventsWithMentions / currentWeekTranscripts.length) * 100).toFixed(1);
                document.getElementById('weeklyMatches').textContent = weeklyPercentage + '%';
            }
        }

        // Helper function to get week number
        function getWeekNumber(date) {
            const d = new Date(Date.UTC(date.getFullYear(), date.getMonth(), date.getDate()));
            const dayNum = d.getUTCDay() || 7;
            d.setUTCDate(d.getUTCDate() + 4 - dayNum);
            const yearStart = new Date(Date.UTC(d.getUTCFullYear(), 0, 1));
            return Math.ceil((((d - yearStart) / 86400000) + 1) / 7);
        }

        // Scroll to transcript
        function scrollToTranscript(transcriptId) {
            const card = document.getElementById(`card-${transcriptId}`);
            if (card) {
                card.scrollIntoView({ behavior: 'smooth', block: 'center' });
                card.style.border = '2px solid #3b82f6';
                setTimeout(() => { card.style.border = '1px solid #374151'; }, 2000);
            }
        }

        // Filter helper functions
        function togglePreview(transcriptId) {
            const preview = document.getElementById(`preview-${transcriptId}`);
            const icon = document.getElementById(`preview-icon-${transcriptId}`);
            const toggle = icon.parentElement;

            if (preview.style.display === 'none') {
                preview.style.display = 'block';
                icon.textContent = '‚ñº';
                toggle.childNodes[1].textContent = ' Hide Full Transcript';
            } else {
                preview.style.display = 'none';
                icon.textContent = '‚ñ∂';
                toggle.childNodes[1].textContent = ' Show Full Transcript';
            }
        }

        function selectAllCategories() {
            document.querySelectorAll('#categoriesFilter input').forEach(cb => cb.checked = true);
            applyFilters();
        }
        function selectNoneCategories() {
            document.querySelectorAll('#categoriesFilter input').forEach(cb => cb.checked = false);
            applyFilters();
        }
        function filterSpeakers() {
            const searchText = document.getElementById('speakerSearch').value.toLowerCase();
            const filterItems = document.querySelectorAll('#speakersFilter .filter-item');

            filterItems.forEach(item => {
                const label = item.querySelector('label').textContent.toLowerCase();
                if (label.includes(searchText)) {
                    item.style.display = '';
                } else {
                    item.style.display = 'none';
                }
            });
        }

        function selectAllSpeakers() {
            const searchText = document.getElementById('speakerSearch').value.toLowerCase();
            document.querySelectorAll('#speakersFilter .filter-item').forEach(item => {
                const label = item.querySelector('label').textContent.toLowerCase();
                // Only select visible speakers (matching search)
                if (item.style.display !== 'none' && (!searchText || label.includes(searchText))) {
                    item.querySelector('input').checked = true;
                }
            });
        }
        function selectNoneSpeakers() {
            const searchText = document.getElementById('speakerSearch').value.toLowerCase();
            document.querySelectorAll('#speakersFilter .filter-item').forEach(item => {
                const label = item.querySelector('label').textContent.toLowerCase();
                // Only deselect visible speakers (matching search)
                if (item.style.display !== 'none' && (!searchText || label.includes(searchText))) {
                    item.querySelector('input').checked = false;
                }
            });
        }
        function selectAllEvents() {
            document.querySelectorAll('#eventsFilter input').forEach(cb => cb.checked = true);
            applyFilters();
        }
        function selectNoneEvents() {
            document.querySelectorAll('#eventsFilter input').forEach(cb => cb.checked = false);
            applyFilters();
        }
        function applyFilters() {
            const btn = document.getElementById('applyFiltersBtn');
            const originalText = btn.textContent;

            // Visual feedback
            btn.textContent = '‚úì Applied!';
            btn.style.background = 'linear-gradient(135deg, #10b981 0%, #059669 100%)';

            // Get filter values
            const startDate = document.getElementById('startDate').value;
            const endDate = document.getElementById('endDate').value;
            const minWordCount = parseInt(document.getElementById('minWordCount').value) || 0;
            const selectedCategories = Array.from(document.querySelectorAll('#categoriesFilter input:checked')).map(cb => cb.value);
            const selectedSpeakers = Array.from(document.querySelectorAll('#speakersFilter input:checked')).map(cb => cb.value);

            // Filter transcripts
            let filtered = transcriptsData.filter(t => {
                // Convert date to comparable format
                const tDate = new Date(t.date);
                const start = new Date(startDate);
                const end = new Date(endDate);

                // Check date range
                if (tDate < start || tDate > end) return false;

                // Check category
                if (!selectedCategories.includes(t.speech_type)) return false;

                // Check minimum word count
                if ((t.word_count || 0) < minWordCount) return false;

                // Check speakers (if transcript has speakers, at least one must be selected)
                if (selectedSpeakers.length > 0 && t.speakers && t.speakers.length > 0) {
                    if (!t.speakers.some(speaker => selectedSpeakers.includes(speaker))) {
                        return false;
                    }
                }

                return true;
            });

            // Sort by date descending
            filtered.sort((a, b) => new Date(b.date) - new Date(a.date));

            // Display filtered transcripts
            displayTranscripts(filtered);

            // Reset button after 1 second
            setTimeout(() => {
                btn.textContent = originalText;
                btn.style.background = 'linear-gradient(135deg, #3b82f6 0%, #2563eb 100%)';
            }, 1000);

            // If there's a search query, also perform search
            if (document.getElementById('searchInput').value.trim()) {
                performSearch();
            }
        }

        // Seek functions for progress bar - with precise positioning and flash highlight
        function seekToMention(event, transcriptId, positionOrWordIndex, type, markerIndex) {
            // Stop propagation to prevent bar click handler
            if (event) {
                event.stopPropagation();
            }

            const previewEl = document.getElementById(`preview-${transcriptId}`);
            if (!previewEl) return;

            // Auto-open preview if collapsed
            if (previewEl.style.display === 'none') {
                togglePreview(transcriptId);
                // Wait a moment for the preview to expand
                setTimeout(() => performSeekAndFlash(), 50);
            } else {
                performSeekAndFlash();
            }

            function performSeekAndFlash() {
                // Find all hit spans of the correct type
                const hitClass = type === 'trump' ? 'hit-trump' : 'hit-other';
                const hits = Array.from(previewEl.querySelectorAll(`.hit.${hitClass}`));
                
                let closestHit = null;
                
                // If we have a marker index, use it directly (most reliable for Trump hits)
                if (typeof markerIndex !== 'undefined' && markerIndex >= 0 && markerIndex < hits.length) {
                    closestHit = hits[markerIndex];
                } else {
                    // Fallback: find closest by position (for backward compat with other speakers)
                    let minDiff = Infinity;
                    hits.forEach(hit => {
                        const hitAbsPos = parseInt(hit.getAttribute('data-abspos'), 10);
                        if (!isNaN(hitAbsPos)) {
                            const diff = Math.abs(hitAbsPos - positionOrWordIndex);
                            if (diff < minDiff) {
                                minDiff = diff;
                                closestHit = hit;
                            }
                        }
                    });
                }

                if (!closestHit) {
                    console.warn(`No hit found for marker ${markerIndex} of type ${type}`);
                    return;
                }

                // Calculate scroll position to place hit in top ~1/3
                const targetTop = closestHit.offsetTop;
                const desiredTop = targetTop - previewEl.clientHeight * 0.33;
                const maxScroll = previewEl.scrollHeight - previewEl.clientHeight;
                previewEl.scrollTop = Math.max(0, Math.min(desiredTop, maxScroll));

                // Add flash highlight
                const flashClass = type === 'trump' ? 'hit-flash-trump' : 'hit-flash-other';
                closestHit.classList.add(flashClass);

                // Remove flash after 1500ms
                setTimeout(() => {
                    closestHit.classList.remove(flashClass);
                }, 1500);
            }
        }

        function seekInTranscript(event, transcriptId) {
            const bar = event.currentTarget;
            const rect = bar.getBoundingClientRect();
            const percent = (event.clientX - rect.left) / rect.width;

            const preview = document.getElementById(`preview-${transcriptId}`);
            if (preview) {
                // First, make sure preview is visible
                if (preview.style.display === 'none') {
                    togglePreview(transcriptId);
                }
                // Calculate scroll position based on transcript length
                const maxScroll = preview.scrollHeight - preview.clientHeight;
                preview.scrollTop = percent * maxScroll;
            }
        }

        // Event listeners
        document.getElementById('searchInput').addEventListener('keypress', (e) => {
            if (e.key === 'Enter') performSearch();
        });
        // Removed auto-search on input - only search on button click or Enter key

        // Load transcript data from API (FULL transcripts from database)
        // Use same-origin relative URLs (works in both production and local via Flask)
        const API_TRANSCRIPTS_URL = '/api/transcripts';
        const API_HEALTH_URL = '/api/health';

        // Load transcript data from API
        async function loadStaticData() {
            try {
                console.log('üì° Loading transcripts from API...');
                const response = await fetch(API_TRANSCRIPTS_URL);
                
                if (!response.ok) {
                    // Show HTTP error with details
                    let errorMsg = '<div class="empty-state">';
                    errorMsg += '<h3>‚ùå API Request Failed</h3>';
                    errorMsg += '<p><strong>The API returned an error.</strong></p>';
                    
                    errorMsg += '<div style="background: rgba(239, 68, 68, 0.1); border: 1px solid #ef4444; border-radius: 6px; padding: 15px; margin: 15px auto; max-width: 600px; text-align: left;">';
                    errorMsg += '<p style="margin-bottom: 8px;"><strong>Endpoint:</strong> <code>' + API_TRANSCRIPTS_URL + '</code></p>';
                    errorMsg += '<p style="margin-bottom: 8px;"><strong>Status:</strong> ' + response.status + ' ' + response.statusText + '</p>';
                    errorMsg += '</div>';
                    
                    errorMsg += '<p><strong>What to try:</strong></p>';
                    errorMsg += '<ul style="text-align: left; margin: 10px auto; max-width: 500px; line-height: 1.8;">';
                    
                    if (response.status === 404) {
                        errorMsg += '<li>The API endpoint was not found. Check that the server is running the correct version.</li>';
                    } else if (response.status >= 500) {
                        errorMsg += '<li>The API server encountered an error. Check server logs or try again in a few moments.</li>';
                        errorMsg += '<li>If on Render, the server may be starting up (cold start). Wait 30-60 seconds and refresh.</li>';
                    } else if (response.status === 403 || response.status === 401) {
                        errorMsg += '<li>Access denied. Check authentication settings.</li>';
                    }
                    
                    errorMsg += '<li>Check the <a href="' + API_HEALTH_URL + '" target="_blank" style="color: #3b82f6;">/api/health</a> endpoint for more info</li>';
                    errorMsg += '<li>Reload the page to try again</li>';
                    errorMsg += '</ul>';
                    
                    errorMsg += '<button onclick="location.reload()" style="margin-top: 20px; padding: 12px 24px; background: linear-gradient(135deg, #3b82f6 0%, #2563eb 100%); color: white; border: none; border-radius: 6px; font-size: 14px; cursor: pointer;">Reload Page</button>';
                    errorMsg += '</div>';
                    
                    document.getElementById('transcriptsSection').innerHTML = errorMsg;
                    return [];
                }
                
                transcriptsData = await response.json();
                console.log(`‚úÖ Loaded ${transcriptsData.length} transcripts from API`);
                
                if (transcriptsData.length === 0) {
                    // Check health endpoint for more info
                    try {
                        const healthResponse = await fetch(API_HEALTH_URL);
                        const health = await healthResponse.json();
                        console.error('‚ö†Ô∏è API returned 0 transcripts. Health check:', health);
                        
                        let errorMsg = '<div class="empty-state">';
                        errorMsg += '<h3>‚ö†Ô∏è No Transcripts Available</h3>';
                        errorMsg += '<p><strong>The API is running but the database is empty.</strong></p>';
                        errorMsg += `<p>Database: <code>${health.database?.path || 'unknown'}</code></p>`;
                        
                        if (!health.database?.exists) {
                            errorMsg += '<p>‚ùå Database file not found!</p>';
                        } else {
                            errorMsg += `<p>üìä Database size: ${health.database?.size_mb || 0} MB</p>`;
                            errorMsg += `<p>üìù Transcript count: ${health.transcripts?.count || 0}</p>`;
                        }
                        
                        errorMsg += '<p><strong>To fix:</strong></p>';
                        errorMsg += '<ol style="text-align: left; margin: 10px auto; max-width: 500px;">';
                        errorMsg += '<li>Ensure the API server is running with the correct database</li>';
                        errorMsg += '<li>Check the server console output for the database path</li>';
                        errorMsg += '<li>If database is empty, run the scraper to populate it</li>';
                        errorMsg += '</ol>';
                        errorMsg += `<p><a href="${API_HEALTH_URL}" target="_blank">View full health check ‚Üí</a></p>`;
                        errorMsg += '</div>';
                        
                        document.getElementById('transcriptsSection').innerHTML = errorMsg;
                    } catch (healthError) {
                        console.error('Could not fetch health info:', healthError);
                    }
                } else if (transcriptsData.length > 0) {
                    console.log(`‚úÖ First transcript: ${transcriptsData[0].preview.length} characters`);
                    console.log(`‚úÖ First 200 chars: ${transcriptsData[0].preview.substring(0, 200)}`);
                }
                
                return transcriptsData;
            } catch (error) {
                console.error('‚ùå Error loading from API:', error);
                
                // Show detailed error message
                let errorMsg = '<div class="empty-state">';
                errorMsg += '<h3>‚ùå Failed to Load Transcripts</h3>';
                errorMsg += '<p><strong>Could not fetch data from the API.</strong></p>';
                
                // Show error details
                errorMsg += '<div style="background: rgba(239, 68, 68, 0.1); border: 1px solid #ef4444; border-radius: 6px; padding: 15px; margin: 15px auto; max-width: 600px; text-align: left;">';
                errorMsg += '<p style="margin-bottom: 8px;"><strong>Endpoint:</strong> <code>' + API_TRANSCRIPTS_URL + '</code></p>';
                errorMsg += '<p style="margin-bottom: 8px;"><strong>Error:</strong> ' + error.message + '</p>';
                errorMsg += '</div>';
                
                // Provide troubleshooting steps
                errorMsg += '<p><strong>Common causes:</strong></p>';
                errorMsg += '<ul style="text-align: left; margin: 10px auto; max-width: 500px; line-height: 1.8;">';
                errorMsg += '<li><strong>Render cold start:</strong> If the server has been inactive, wait 30-60 seconds and refresh</li>';
                errorMsg += '<li><strong>Network issue:</strong> Check your internet connection</li>';
                errorMsg += '<li><strong>Browser extension:</strong> Try disabling ad blockers</li>';
                errorMsg += '<li><strong>API down:</strong> Check <a href="' + API_HEALTH_URL + '" target="_blank" style="color: #3b82f6;">/api/health</a> for status</li>';
                errorMsg += '</ul>';
                
                errorMsg += '<button onclick="location.reload()" style="margin-top: 20px; padding: 12px 24px; background: linear-gradient(135deg, #3b82f6 0%, #2563eb 100%); color: white; border: none; border-radius: 6px; font-size: 14px; cursor: pointer;">Reload Page</button>';
                errorMsg += '</div>';
                
                document.getElementById('transcriptsSection').innerHTML = errorMsg;
                
                return [];
            }
        }

        // Speaker list for parsing (186 speakers)
        const SPEAKERS = ["Donald Trump", "Keir Starmer", "Unidentified Speaker", "Emmanuel Macron", "Narendra Modi", "Shigeru Ishiba", "Benjamin Netanyahu", "Sean Duffy", "Pete Hegseth", "J.D. Vance", "Anne Fundner", "Mike Johnson", "Janet Mills", "Jim Pillen", "Richard Attias", "Rosanna Maietta", "Borge Brende", "Stephen Schwarzman", "Patrick Pouyann√©", "Brian Moynihan", "Ana Botin", "Laura Ingraham", "Kamala Harris", "Tammy Nobles", "Jonathan Martinez", "Tom Cole", "Steve Eagar", "Elon Musk", "R. Lee Ermey", "Rachel Levine", "Matthew Modine", "Kylie Minogue", "Qveen Herby", "Marines", "Kid Rock", "Will Scharf", "Aide", "Paula White-Cain", "Alina Habba", "Pam Bondi", "Randy Fine", "Howard Lutnick", "Nicole Malliotakis", "Sergio Gor", "Charles Kushner", "James Blair", "David Perdue", "Leah Campos", "Michael Waltz", "John Arrigo", "Kevin Cabrera", "Tom Barrack", "Pete Hoekstra", "Ron Johnson", "Matt Whitaker", "George Glass", "Ken Howery", "Stacey Feinberg", "Nicole McGraw", "Brandon Judd", "Brian Burch", "Somers Farkas", "Joe Popolo", "Mike Huckabee", "Tilman Fertitta", "Warren Stephens", "Jimmy Patronis", "Alek Skarlatos", "Kimberly Guilfoyle", "Doug Burgum", "Brooke Rollins", "Kelly Loeffler", "Lee Zeldin", "Doug Collins", "Chris Wright", "Linda McMahon", "Robert F. Kennedy, Jr.", "Kristi Noem", "Marco Rubio", "Scott Bessent", "Euisun Chung", "Steve Scalise", "Jeff Landry", "David W. Allvin", "Dale R. White", "Mary Martin", "Chuck Robbins", "Gianni Infantino", "Kevin Hassett", "David Sacks", "Tom Emmer", "Cameron Winklevoss", "Tyler Winklevoss", "Sergey Nazarov", "Rodolphe Saad√©", "Lindsey Halligan", "Maria Bartiromo", "C.C. Wei", "Scott Turner", "Ron DeSantis", "Tiger Woods", "Tim Scott", "Leo Terrell", "Phil Heath", "Neil Gorsuch", "Cheryl Hines", "Tulsi Gabbard", "Abraham Williams", "Steve Witkoff", "Marc Fogel", "Dave McCormick", "Mark Fogel", "Stephen Miller", "Clarence Thomas", "Nancy Mace", "Tim Burchett", "Ronny Jackson", "Payton McNabb", "Paul Maurice", "Sergei Bobrovsky", "Vinnie Viola", "Sam Reinhart", "Matthew Tkachuk", "Allyson Phillips", "Franklin Graham", "Melania Trump", "Karen Bass", "Brad Sherman", "Judy Chu", "Kathryn Barger", "Vince Fong", "Kevin Kiley", "Joel Pollak", "Jay Obernolte", "Young Kim", "George Whitesides", "Traci Park", "Tom McClintock", "Ed Ring", "Ric Grenell", "Michael Whatley", "Larry Ellison", "Masayoshi Son", "Sam Altman", "Amy Klobuchar", "John Thune", "Chuck Schumer", "Hakeem Jeffries", "Deb Fischer", "John Roberts", "Chris LaNeve", "Joe Biden", "Karoline Leavitt", "Sarah Huckabee Sanders", "Peter Navarro", "Russell Vought", "Charlie Kirk", "Lara Trump", "Eric Trump", "Mike Pompeo", "Sean Hannity", "Nikki Haley", "Greg Abbott", "Brian Kemp", "Tom Homan", "Marty Makary", "Adam Boehler", "Bruce LeVell", "Bryson DeChambeau", "Chip Roy", "David Pecker", "Emil Bove", "Hope Hicks", "Jake Tapper", "Joshua Steinglass", "Juan Merchan", "Matthew Colangelo", "Mike Lindell", "Patty Morin", "Sean O'Brien", "Saudi Protocol Officer", "Tamim bin Hamad Al Thani", "Todd Blanche", "Tom Hauser", "Mark Rutte"];

        // Build speaker lookup set for efficient checking
        const SPEAKER_SET = new Set(SPEAKERS.map(s => s.toLowerCase()));

        // Parse transcript into speaker turns with offsets
        // Returns: { turns: [{speaker, dialogueLines, dialogueStartOffset}], totalLength }
        function parseTranscriptTurns(preview) {
            const lines = preview.split('\n');
            const turns = [];
            let currentSpeaker = null;
            let currentDialogueLines = [];
            let currentDialogueStartOffset = 0;
            let absoluteOffset = 0;

            for (let i = 0; i < lines.length; i++) {
                const line = lines[i];
                const lineLength = line.length + 1; // +1 for \n
                const lineTrimmed = line.trim();

                // Check if this line is a speaker name (exact match, case-insensitive)
                const isSpeakerLine = SPEAKER_SET.has(lineTrimmed.toLowerCase());

                if (isSpeakerLine) {
                    // Save previous turn if exists
                    if (currentSpeaker && currentDialogueLines.length > 0) {
                        turns.push({
                            speaker: currentSpeaker,
                            dialogueLines: currentDialogueLines,
                            dialogueStartOffset: currentDialogueStartOffset
                        });
                    }

                    // Start new turn
                    currentSpeaker = lineTrimmed;
                    currentDialogueLines = [];
                    // Next line will be dialogue, so offset is after this speaker line
                    currentDialogueStartOffset = absoluteOffset + lineLength;
                } else if (currentSpeaker) {
                    // This is dialogue for the current speaker
                    currentDialogueLines.push(line);
                }

                absoluteOffset += lineLength;
            }

            // Save final turn
            if (currentSpeaker && currentDialogueLines.length > 0) {
                turns.push({
                    speaker: currentSpeaker,
                    dialogueLines: currentDialogueLines,
                    dialogueStartOffset: currentDialogueStartOffset
                });
            }

            return { turns, totalLength: preview.length };
        }

        /**
         * UNIFIED TRUMP-ONLY, WORD-BASED MATCH COMPUTATION
         * This is the single source of truth for all match counts and positions.
         * Used by: performSearch, updateMentionsChart, displayTranscripts, updateLocationChart
         */
        function computeTrumpMatches(preview, terms) {
            if (!preview || !terms || terms.length === 0) {
                return {
                    mention_count: 0,
                    mention_locations: [],
                    trump_only_words: [],
                    trump_only_text: '',
                    debug: { terms, preview_length: preview ? preview.length : 0 }
                };
            }

            // Parse transcript into turns
            const { turns } = parseTranscriptTurns(preview);
            
            // Extract Trump-only dialogue and build word stream
            const trumpTurns = turns.filter(turn => turn.speaker === 'Donald Trump');
            const trumpOnlyText = trumpTurns.map(turn => turn.dialogueLines.join(' ')).join(' ');
            
            // Tokenize into words (split on whitespace)
            const words = trumpOnlyText.split(/\s+/).filter(w => w.length > 0);
            const totalWords = words.length;

            if (totalWords === 0) {
                return {
                    mention_count: 0,
                    mention_locations: [],
                    trump_only_words: [],
                    trump_only_text: '',
                    debug: { terms, trump_turns: trumpTurns.length, total_words: 0 }
                };
            }

            // Find all matches in Trump's dialogue
            const mentionLocations = [];
            let mentionCount = 0;
            const trumpOnlyLower = trumpOnlyText.toLowerCase();

            terms.forEach(term => {
                const termLower = term.toLowerCase();
                let pos = 0;
                
                while ((pos = trumpOnlyLower.indexOf(termLower, pos)) !== -1) {
                    // Count words up to this position to get word index
                    const textBeforeMatch = trumpOnlyText.substring(0, pos);
                    const wordsBeforeMatch = textBeforeMatch.split(/\s+/).filter(w => w.length > 0);
                    const wordIndex = wordsBeforeMatch.length;
                    
                    // Calculate normalized location (0..1) with clamping
                    const location = Math.max(0, Math.min(1, wordIndex / Math.max(totalWords, 1)));
                    
                    mentionCount++;
                    mentionLocations.push({
                        location: location,
                        position_word: wordIndex,
                        total_words: totalWords,
                        term: term,
                        char_pos: pos  // Keep for backward compat during transition
                    });
                    
                    pos += termLower.length;
                }
            });

            return {
                mention_count: mentionCount,
                mention_locations: mentionLocations,
                trump_only_words: words,
                trump_only_text: trumpOnlyText,
                debug: {
                    terms: terms,
                    trump_turns: trumpTurns.length,
                    total_words: totalWords,
                    matches_found: mentionCount
                }
            };
        }

        // Parse speakers from text
        function parseSpeakers(text) {
            const found = [];
            for (const speaker of SPEAKERS) {
                const pattern = new RegExp(`(?:^|\\n)\\s*${speaker.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')}\\s*:`, 'im');
                if (pattern.test(text)) {
                    found.push(speaker);
                }
            }
            return found;
        }

        // Sync/Refresh transcripts from RollCall
        async function syncTranscripts() {
            const btn = document.getElementById('syncBtn');
            btn.textContent = '‚ü≥ Syncing...';
            btn.disabled = true;

            try {
                // Trigger scraper via API
                const response = await fetch('/api/scraper/refresh', {
                    method: 'POST'
                });

                if (!response.ok) {
                    throw new Error('Failed to start scraper');
                }

                const data = await response.json();
                console.log('Scraper response:', data);

                if (data.status === 'already_running') {
                    btn.textContent = 'Already Running';
                    setTimeout(() => {
                        btn.textContent = '‚ü≥ Sync Transcripts';
                        btn.disabled = false;
                    }, 2000);
                    return;
                }

                // Poll for status
                btn.textContent = 'Running...';
                const pollInterval = setInterval(async () => {
                    try {
                        const statusResponse = await fetch('/api/scraper/status');
                        const status = await statusResponse.json();

                        console.log('Scraper status:', status);

                        if (status.progress) {
                            btn.textContent = status.progress.substring(0, 20);
                        }

                        if (!status.running) {
                            clearInterval(pollInterval);
                            btn.textContent = '‚úì Complete!';

                            // Reload data
                            await loadStaticData();

                            setTimeout(() => {
                                btn.textContent = '‚ü≥ Sync Transcripts';
                                btn.disabled = false;
                            }, 2000);
                        }
                    } catch (e) {
                        console.error('Status poll error:', e);
                    }
                }, 2000);

                // Timeout after 5 minutes
                setTimeout(() => {
                    clearInterval(pollInterval);
                    btn.textContent = '‚ü≥ Sync Transcripts';
                    btn.disabled = false;
                }, 300000);

            } catch (error) {
                console.error('Sync error:', error);
                btn.textContent = '‚úó Sync Failed';
                setTimeout(() => {
                    btn.textContent = '‚ü≥ Sync Transcripts';
                    btn.disabled = false;
                }, 3000);
            }
        }

        // Initialize
        window.addEventListener('DOMContentLoaded', async () => {
            initCharts();

            // ALWAYS load from API - NO CACHE
            console.log('üîÑ Loading transcripts from API (cache disabled)...');
            transcriptsData = await loadStaticData();

            console.log('‚úÖ Loaded transcripts:', transcriptsData.length);

            await loadInitialData();

            // Apply initial filters to show transcripts within default date range
            applyFilters();
        });
    </script>

    <!-- Floating Sync Button -->
    <button id="syncBtn" onclick="syncTranscripts()" style="
        position: fixed;
        bottom: 20px;
        left: 20px;
        padding: 12px 20px;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        border: none;
        border-radius: 25px;
        font-size: 14px;
        font-weight: 600;
        cursor: pointer;
        box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4);
        transition: all 0.3s ease;
        z-index: 1000;
    " onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 6px 20px rgba(102, 126, 234, 0.6)'"
       onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='0 4px 15px rgba(102, 126, 234, 0.4)'">
        ‚ü≥ Sync Transcripts
    </button>
</body>
</html>
